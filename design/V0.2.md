# JumboDB V0.2

Based on the architecture diagram in V0.2.drawio, 
this version will implement a lsm tree based storage engine
to make sure the database can persistence data into disk

This version had added a couple of attributes into the config.yaml,
most of them are related to storage engine.
 
## Config

[storage]

bloomFilterFalsePositiveRate = 0.03 the default bloomfilter error rate
if that rate is too low, it will improve huge memory cost 

memoryTableSize = 3 the default memtable size

skipListLevel = 10 the default skiplist level of memtable

SSTableIndexLocation = "ssTableIndex.index" the sstable index location
it include the sstable file names and related bloomfilters

WALLocation = "wal.jumbo" the acutal wal location that inclue 
all operation of databse

LSMIndexLocation = "lsm.index" the lsm tree index location, 
in that version it only have current index of WAL which will 
be use when db start

engine = "lsm" or "hashmap" lsm will use the lsm tree 
as the storage engine, hashmap will use the V0.1 inmemory hashmap


## API

GET /health - liveness check for the database

GET /resources - list all the data as list of K,V pair

POST /resources - create one K,V pair in db

GET /resources/{key} - get value from db by key

DELETE /resources/{key} - delete K,V pair in db

## Start server
in jumboDB-core/cli 

```azure
go run main.go 
```

## Dashboard
in dashboard

```azure
npm start
```

## Configuration
In that version, all the database config are located in 
jumboDB-core/cli/config.toml which have following flags

| Block  | Key | Default | Definition|
| ------------- | ------------- | ------------- | ------------- |
| Connection  | port  | 38421 | The port that db server listening| 

## Why design like that
In that version, the majority goal is to make a service 
that can provide K,V pair storage and query and complete 
the not important parts of the database.


Not important parts include the protocol of between the 
server and client, there have two choice here. 

1. Use binary based protocol + TCP socket, like a RPC protocol.
2. Use existing library/protocol.

I believe that for now, we need to build the db as quicker 
as it can and focuse on the storage engine in next chapter. 
So I decided to use the http plus restful API on that.

Storage is follow the same though, this version is to make 
a workable version of K,V database, the inmemory hashmap is 
good enough to achieve that goal, no need to add extra complexity




